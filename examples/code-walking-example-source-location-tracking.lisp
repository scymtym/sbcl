(cl:in-package #:cl-user)

(defun form-path-in-macro-arguments (form arguments)
  (labels ((rec (current path)
             (cond
               ((eq current form)
                (return-from form-path-in-macro-arguments (nreverse path)))
               ((consp current)
                (rec (car current) (list* 'car path))
                (rec (cdr current) (list* 'cdr path)))
               ((sb-int:comma-p current)
                (rec (sb-int:comma-expr current) (list* 'sb-int:comma-p path)))
               ((symbolp current)
                nil)
               (t
                (break)))))
    (rec arguments '())))

;; TODO (:argument . pre-macro-path) -> compiler error

(defvar *path*)
(defvar *macro-arguments*)
(defvar *in-expansion*)
(defun walk-with-source-locations (form)
  (let* ((env (sb-c::coerce-to-lexenv nil))
         (sb-c::*lexenv* env)
         (*path* '())
         (*macro-arguments* '())
         (*in-expansion* nil))
    (labels ((recurse-with-identified-component/1 (recurse component key form)
               (let ((*path* (list* key *path*)))
                 (funcall recurse :components (list key form))))
             (recurse-with-identified-component/* (recurse component key form)
               (list
                key
                (loop :for i :from 0 :below (length form) :collect
                   (let ((*path* (list* (cons key i) *path*)))
                     (second (funcall recurse :components (list (cons key i) form)))))))
             (recurse-with-identified-components (recurse info components)
               (loop :for (key form) :on components :by #'cddr
                  :append (let ((component (find key (sb-c::operator-info-components
                                                      info)
                                                 :key #'sb-c::operator-component-name)))
                            (ecase (sb-c::operator-component-cardinality component)
                              ((1 sb-c::?)
                               (recurse-with-identified-component/1
                                recurse component key form))
                              (t
                               (recurse-with-identified-component/*
                                recurse component key form)))))))
      (sb-c:walk-forms
       'list
       (lambda (instead recurse form kind name &rest components)
         (declare (ignore instead))
         (multiple-value-bind (*path* *macro-arguments* *in-expansion*)
             (alexandria:if-let ((pre-macro-path (when *macro-arguments*
                                                   (form-path-in-macro-arguments
                                                    form (car *macro-arguments*)))))
                                (values (list* (cons :argument pre-macro-path) (cdr *macro-arguments*))
                                        nil
                                        nil)
                                (values *path* *macro-arguments* *in-expansion*))
           (let ((*print-pretty* nil))
             (format t "~80A => ~:[~60A~:;generated by macro~]~%"
                     form *in-expansion* (reverse *path*)))
           (typecase kind
             (sb-c:leaf-info
              name)
             (sb-c:macroid-info
              (let* ((*path*            (list* (cons :macro name) *path*))
                     (arguments         (getf components :arguments))
                     (*macro-arguments* (cons arguments *path*))
                     (*in-expansion*    t)
                     (expansion         (funcall recurse)))
                expansion))
             (sb-c:special-operator-info
              (let ((*path* (list* name *path*)))
                (apply #'sb-c:reconstitute form kind name
                       (recurse-with-identified-components
                        recurse kind components))))
             (t
              (let ((*path* (list* :call *path*)))
                (apply #'sb-c:reconstitute form kind name
                       (recurse-with-identified-components
                        recurse kind components)))))))
       form
       (lambda (form)
         (sb-c:classify-variable-form form sb-c::*lexenv*))
       (lambda (form)
         (sb-c:classify-application-form form sb-c::*lexenv*))
       (lambda (kind expander form)
         (sb-c:expand-macro kind expander form sb-c::*lexenv*))))))

(walk-with-source-locations
 '(with-output-to-string (stream)
   (loop :for bla :in foo :do (write-string bla stream))))

(progn
  (format t "~80A => ~60A~%" "sub-form" "path")
  (walk-with-source-locations
   '(let ((quote #1=(fun 1 2)))
     #1#
     (quote (foo 4 5))
     `(,foo)
     (when a (bar (return (+ b))))
     1)))

(walk-with-source-locations
 `(and (if 1 2 3)
       (let ((quote (fun 1 2)))
         (append :bar '(a b c (e f :foo))))))

(defun f ()
  (with-output-to-string (stream)
    (loop :for bla :in foo :do (write-string bla stream))))
